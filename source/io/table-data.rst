表数据
======

英文称为table data，也称为列数据或多列数据，常用于表示点和线。表数据中有N个记录，
每个记录都有M个字段。

表数据可以有三种形式：ASCII表、二进制表和netCDF表。最常用的表数据形式是ASCII表，
可以用编辑器直接编辑。ASCII表中有N行M列，每行是一个记录，每列是一个字段。
一个记录内的字段之间用空格、制表符、逗号或分号分隔。

ASCII表
-------

ASCII表简介
~~~~~~~~~~~

ASCII表是最常见的数据形式，可以用编辑器直接编辑。数据中有N行M列，每行是一个记录，
每列是一个字段。一个记录内的字段之间用空格、制表符、逗号或分号分隔。每个字段可以
是整数（ ``12`` ）、浮点数（ ``20.34`` ）、地理坐标（ ``12:23:44.5W`` ）、
绝对时间（ ``2010-10-20T10:30:53.250`` ）、相对时间（ ``30t`` ），同时，
GMT还可以处理大多数CVS（Comma-Separated Values）文件，包括被双引号扩起来的数字。

例如::

    # This is a comment line
    # lon      lat  evdp
    # This is another comment line
    133.949  34.219  20
    133.528  34.676  15
    130.233  33.410  43
    135.133  35.313  35
    131.377  34.398  22
    132.792  34.457  34
    133.620  34.936  6
    131.101  32.811  23
    129.435  33.212  55
    133.144  33.647  67

记录中以 ``#`` 开头的行，即第一列是 ``#`` 的记录，会被当做注释行直接忽略，
不算在N个记录之内。所以这个ASCII表可以认为有10行3列，三列数据分别代表经度、纬度和深度。

不同的模块和选项的组合会对数据的列数以及每列的含义都有不同的定义，因而需要
根据具体情况去准备数据。准备数据的过程中可能会用到GMT的 ``-i`` 、 ``-o`` 选项以及 ``gawk`` 等工具。

在输出ASCII 表时，字段之间默认用 TAB 键分隔，可以通过修改 
:ref:`IO_COL_SEPARATOR <IO_COL_SEPARATOR>` 来设置字段的分隔符，

文件头记录
~~~~~~~~~~

在第一个记录前，可以有一个或多个与数据无关的记录，称为文件头记录（file header records）。

记录中以 ``#`` 开头的行都被当做注释忽略，所以不算是文件头记录。其他不以 ``#`` 
开头但与数据无关的行，则是文件头记录。要使用 ``-h`` 选项或设置参数 
:ref:`IO_N_HEADER_RECS <IO_N_HEADER_RECS>` 跳过这些文件头记录。

下面的ASCII表有一个文件头记录，可以使用 ``-h1`` 选项跳过该文件头段记录::

        # This is a comment line
        # lon      lat  evdp
        # This is another comment line
        2015-01-05 10:20:30.456 15 45 60 6.0
        133.949  34.219  20
        133.528  34.676  15
        130.233  33.410  43
        135.133  35.313  35
        131.377  34.398  22
        132.792  34.457  34
        133.620  34.936  6
        131.101  32.811  23
        129.435  33.212  55
        133.144  33.647  67

数据段头记录
~~~~~~~~~~~~

在绘制断层的时候，可以将每个断层的经纬度信息分别放在各自的文件中，但当断层数量
很多时，这样做可能导致目录下有太多数据文件而混乱不堪。为了解决类似的问题，GMT
引入了多段数据的概念。

多段数据，顾名思义，就是一个文件中包含了多个数据段。为了区分每个数据段，需要在
每段数据的开头加上一个额外的数据段头记录（segment header records）来标记一段新数据的开始。

数据段头记录可以是任意格式，但所有数据段头记录的第一列字符必须相同。
GMT中默认的数据段头记录的首字符为 ``>`` ，也可以通过修改 
:ref:`IO_SEGMENT_MARKER <IO_SEGMENT_MARKER>` 设置为其他字符。

:ref:`IO_SEGMENT_MARKER <IO_SEGMENT_MARKER>` 可以取两个特殊的值：

- 取 ``B`` 表示用空行作为数据段的分隔符
- 取 ``N`` 表示用一个所有列都是NaN的记录作为数据段分隔符

下面是一个包含两个数据段的多段数据，每段数据是一个多边形::

    >
    10  20
    15  30
    12  25
    >
    22  20
    30  30
    40  50
    35  44

数据段头记录不仅仅用于标记数据段的开始，还可以额外指定该段数据的其他属性。比如：

- ``-D`` 指定某个距离值
- ``-W`` 指定当前数据段的画笔颜色
- ``-G`` 指定当前数据段的填充色
- ``-Z`` 设置当前数据对应的Z值，并从CPT文件中获取Z值对应的颜色
- ``-L`` 设置当前数据段的标签信息
- ``-T`` 设置当前数据段的一般描述信息
- ``-Ph`` 表明当前数据段构成的闭合多边形位于另一个闭合多边形的内部
- ...

这些数据段头记录中的选项参数将覆盖命令行中相应选项的值。

下面的多段数据，分别设置两段数据拥有不同的画笔颜色::

    > -W2p,red
    10  20
    15  30
    12  25
    > -W2p,blue
    22  20
    30  30
    40  50
    35  44

二进制表
--------

对于IO密集型任务，可以以二进制表的形式读写数据文件以加速。

简单地说，ASCII表与二进制表的区别在于前者使用 ``fprintf`` 输出而后者使用 
``fwrite`` 输出。GMT在读取二进制表数据时，无法直接判断数据中有多少个记录，
每个记录有多少个字段。因而需要使用 ``-bi`` 选项指定二进制表数据的格式，
详情见 :doc:`/option/binary` 。

二进制表中也可以有文件头记录，用 ``-h`` 选项可以指定要跳过的字节数。
二进制表也可以表示多段数据，此时用一个值为 ``NaN`` 的记录作为数据段头记录来标记每段数据的开始。

NetCDF表
--------

表数据也可以用NetCDF格式保存，该格式的好处在于通用。比如GMT自带的海岸线数据就是
NetCDF的表数据。NetCDF表数据中包含了一个或多个一维数组，每个一维数组都有对应的
变量名（比如 ``lon`` 、 ``lat`` 、 ``vel`` 等等），由于NetCDF格式的数据中包含了
很多元数据（meta data），所以读取就变得很容易。

默认情况下，GMT在读入NetCDF表时会从第一个一维数组开始读，并将其作为输入的第一列，
然后再读入第二个一维数组，将其作为输入的第二列，依次循环下去，直到读完自己所需要的字段数。

若需要手动指定要从NetCDF表中读入哪些变量，可以在netCDF表文件名后加上后缀 
``?<var1>/<var2>/...`` ，也可以直接使用 ``-bic<var1>/<var2>/...`` 选项。
其中 ``<var1>`` 等是要从NetCDF表中读入的变量名。比如 ``file.nc?lon/lat`` 
表示要从文件中读入 ``lon`` 和 ``lat`` 两个一维数组作为输入数据。

目前，GMT只支持读取netCDF表数据，不支持写netCDF表数据。
